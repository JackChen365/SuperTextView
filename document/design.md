## 设计

* 在Span之外,重新设计了元素自身定位属性

```
/**
 * 跟随内容向右流动
 */
public static final int FLOW=FLOW_FLAG;
/**
 * 标记段落,后续内容按此段落信息流动
 */
public static final int PARAGRAPH =PARAGRAPH_FLAG | CONSIDER_BREAK_LINE_FLAG;
/**
 * 标记段落,并自动断行
 */
public static final int PARAGRAPH_BREAK_LINE=PARAGRAPH_FLAG | BREAK_LINE_FLAG;
/**
 * 当前控件自动换行
 */
public static final int BREAK_LINE=BREAK_LINE_FLAG;
/**
 * 标志span按flow摆放,但如果超出尺寸 ,则放到下一行
 */
public static final int CONSIDER_BREAK_LINE=FLOW_FLAG | CONSIDER_BREAK_LINE_FLAG;
/**
 * 跟随内容,排版后换行
 */
public static final int FLOW_SINGLE_LINE=FLOW_FLAG | BREAK_LINE_FLAG | SINGLE_LINE_FLAG;
/**
 * 独占一行
 */
public static final int SINGLE_LINE=BREAK_LINE_FLAG | SINGLE_LINE_FLAG;
```
* 在当前的属性集中,添加了三个额外参数,用于确定元素的绘制起始位置，结束位置（因为存在同行，多条信息）

```
private static final int START = 0;
private static final int TOP = 1;
private static final int DESCENT = 2;
private static final int LEFT = 3;//文本起始绘制位置
private static final int BOTTOM=4;//文本底部位置,因为存在一行内,多行信息
private static final int ALIGN = 5;//文本对齐标志
```


* 元素排版影响

1. 会影响尺寸变化的是 MetricAffectingSpan
2. 根据单词元素做切词操作的动态排版影响
3. 根据强行设置的标志,检测的换行操作影响
4. 段落的影响,以及段落内,再附加一个段落,可能的情况(暂不考虑)
5. 元素行的靠顶部,居中,以及底部对齐
6. 强行断行,对下一行的绘制影响


### 关于灵活度更高的元素嵌入机制
时间:2019/12/27
问题:
以前的段落,与span高度绑定,以View标识的方式,动态的嵌入控件,并完成排版.好处是,融入到整个文本运算,排版,过程中.并不需要多余的考虑.
缺点是:因为内容完全动态化,就不容易做类似于,我想放一个控件,在段落顶部,或者段落末尾.并影响后续的文本排版.这局限了所有文本的动态性.

基于以上问题.最终思考到的是.加入元素动态扩展机制.元素融入到文本排版过程中.干扰文本排版.

如 左侧加入元素.文本检测到左侧有元素.将左侧排版位置向右偏移.同样如果元素放在右侧.文本排版到右侧.自动以右侧为边界.而不是原来文本边界.
这里产生的问题是:
1. 如果将元素插入到中间怎么办?
2. 如果多个元素叠加干扰怎么办?
3. 以上信息都解决后,如何解决.行信息,被分割后的情况,滚动复用问题.
    3.1:中间有两个元素介入,元素以行向前排
        -----------------------------
        我们|******|是|******|好朋友.
        ----|******|--|******|-------
        但是|******|他|******|关系并不
        ----|******|--|******|-------
    3.2:如果文本是各下段落顺移
        -----------------------------
        我们|******|,但是|******|并不
        ----|******|-----|******|----
        是好|******|他们 |******|是很
        ----|******|-----|******|----
        朋友|******|关系 |******|好.
        ----|******|-----|******|----

当屏幕滚动信息向上时.无法直接检测出行加载信息.除非他们是一个整体

关于以上问题.如果想从根本解决.
第一种方案:改变文本以行为单位的复用规则.这样可以需要做横纵向的滚动扩展支持.这种实施起来难度很大.并且需要改动当前很多很多结构
第二种方案:扩展出视图渲染元素机制.如文本行是一个渲染元素,占据当前行位置.段落是一个扩展的渲染元素.而以上任一元素,都可以自由扩展渲染元素类似于,请求信息时,只需要知道.矩阵大小.占据文本范围.并不需要关心内部控件排版.这样可以自由扩展任何场景.如不占用任何文本,但是可以空间一块区域空间,中间放置一个表单.扩展自由度极高.


### 关于扩展元素设计
基本信息为:
1. 矩阵空间(left,top,right,bottom)
2. 当前滚动值
3. 字符,使用字符起始,结束位置
4. 行装饰器设置的空余空间


#### 为了实现自由扩展的文本扩展元素,需要做的前置工作有
1. 以最精减的文本排版代码(包括span运算)为计算核心进行扩展,这一步需要进行抽离
2. 所有扩展元素,需要做一层文本计算干预逻辑,如当前文本排到100,这时候,我需要截断文本排版.比如我自定义元素.需要50个字符,这50个字符在我的扩展元素内,具体怎么排版.绘不绘制外围不需要知道.
只是排版到此处时.我告诉外围我需要高度为200,需要排版字符向前前进50个字符.这内部,我可以自由进行任何操作.

#### 可能存在的问题
1. 需要元素支持额外的属性,用来支持动画操作.
2. 需要考虑后续的文本动态增删对动态元素的影响.